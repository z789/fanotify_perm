diff -Nurp linux-3.10.0-1127.13.1.el7.x86_64.orig/fs/notify/fanotify/fanotify.c linux-3.10.0-1127.13.1.el7.x86_64/fs/notify/fanotify/fanotify.c
--- linux-3.10.0-1127.13.1.el7.x86_64.orig/fs/notify/fanotify/fanotify.c	2020-12-04 19:34:12.231398192 +0800
+++ linux-3.10.0-1127.13.1.el7.x86_64/fs/notify/fanotify/fanotify.c	2020-12-04 19:36:57.006460776 +0800
@@ -9,9 +9,18 @@
 #include <linux/types.h>
 #include <linux/wait.h>
 #include <linux/audit.h>
+#include <linux/spinlock.h>
 
 #include "fanotify.h"
 
+#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
+unsigned long max_time_do_perm;
+DEFINE_SPINLOCK(max_time_lock);
+
+extern unsigned long time_wait_response;
+extern int response_timeout;
+#endif
+
 static bool should_merge(struct fsnotify_event *old_fsn,
 			 struct fsnotify_event *new_fsn)
 {
@@ -64,7 +73,21 @@ static int fanotify_get_response(struct
 
 	pr_debug("%s: group=%p event=%p\n", __func__, group, event);
 
-	wait_event(group->fanotify_data.access_waitq, event->response);
+	ret = wait_event_timeout(group->fanotify_data.access_waitq, event->response,
+                           time_wait_response);
+
+	if (!ret) {       //timeout 
+		spin_lock(&group->notification_lock);
+		if (!(list_empty(&event->fae.fse.list))) {
+			list_del_init(&event->fae.fse.list);
+
+			//event listed to group->notification_list
+			if (event->stat == FANOTIFY_EVENT_INIT)
+				group->q_len--;
+			event->response = response_timeout;
+		}
+		spin_unlock(&group->notification_lock);
+	}
 
 	/* userspace responded, convert to something usable */
 	switch (event->response & ~FAN_AUDIT) {
@@ -153,6 +176,8 @@ struct fanotify_event_info *fanotify_all
 			return NULL;
 		event = &pevent->fae;
 		pevent->response = 0;
+		pevent->stat = FANOTIFY_EVENT_INIT;
+		pevent->start_time = jiffies;
 		goto init;
 	}
 #endif
@@ -192,6 +217,8 @@ static int fanotify_handle_event(struct
 	BUILD_BUG_ON(FAN_OPEN_PERM != FS_OPEN_PERM);
 	BUILD_BUG_ON(FAN_ACCESS_PERM != FS_ACCESS_PERM);
 	BUILD_BUG_ON(FAN_ONDIR != FS_ISDIR);
+	BUILD_BUG_ON(FAN_OPEN_EXEC != FS_OPEN_EXEC);
+	BUILD_BUG_ON(FAN_OPEN_EXEC_PERM != FS_OPEN_EXEC_PERM);
 
 	if (!fanotify_should_send_event(iter_info, mask, data, data_type))
 		return 0;
@@ -260,8 +287,14 @@ static void fanotify_free_event(struct f
 	put_pid(event->tgid);
 #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
 	if (fsn_event->mask & FAN_ALL_PERM_EVENTS) {
-		kmem_cache_free(fanotify_perm_event_cachep,
-				FANOTIFY_PE(fsn_event));
+		struct fanotify_perm_event_info *pevent = FANOTIFY_PE(fsn_event);
+		unsigned long cost = jiffies_to_usecs(jiffies - pevent->start_time);
+		spin_lock(&max_time_lock);
+		if (cost > max_time_do_perm)
+			max_time_do_perm = cost;
+		spin_unlock(&max_time_lock);
+
+		kmem_cache_free(fanotify_perm_event_cachep, pevent);
 		return;
 	}
 #endif
diff -Nurp linux-3.10.0-1127.13.1.el7.x86_64.orig/fs/notify/fanotify/fanotify.h linux-3.10.0-1127.13.1.el7.x86_64/fs/notify/fanotify/fanotify.h
--- linux-3.10.0-1127.13.1.el7.x86_64.orig/fs/notify/fanotify/fanotify.h	2020-12-04 19:34:12.231398192 +0800
+++ linux-3.10.0-1127.13.1.el7.x86_64/fs/notify/fanotify/fanotify.h	2020-12-04 19:34:39.878321285 +0800
@@ -22,6 +22,11 @@ struct fanotify_event_info {
 };
 
 #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
+enum fanotify_event_stat {
+	FANOTIFY_EVENT_INIT   = 0,
+	FANOTIFY_EVENT_SENDED = 1,
+};
+
 /*
  * Structure for permission fanotify events. It gets allocated and freed in
  * fanotify_handle_event() since we wait there for user response. When the
@@ -31,6 +36,8 @@ struct fanotify_event_info {
  */
 struct fanotify_perm_event_info {
 	struct fanotify_event_info fae;
+	unsigned long start_time;
+	unsigned int stat;
 	int response;	/* userspace answer to question */
 	int fd;		/* fd we passed to userspace for this event */
 };
diff -Nurp linux-3.10.0-1127.13.1.el7.x86_64.orig/fs/notify/fanotify/fanotify_user.c linux-3.10.0-1127.13.1.el7.x86_64/fs/notify/fanotify/fanotify_user.c
--- linux-3.10.0-1127.13.1.el7.x86_64.orig/fs/notify/fanotify/fanotify_user.c	2020-12-04 19:34:12.231398192 +0800
+++ linux-3.10.0-1127.13.1.el7.x86_64/fs/notify/fanotify/fanotify_user.c	2020-12-04 22:14:10.442996881 +0800
@@ -44,6 +44,51 @@ struct kmem_cache *fanotify_mark_cache _
 struct kmem_cache *fanotify_event_cachep __read_mostly;
 struct kmem_cache *fanotify_perm_event_cachep __read_mostly;
 
+#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
+unsigned long time_wait_response = HZ/25;
+static unsigned long min_time_wait_response = HZ/50;
+static unsigned long max_time_wait_response = HZ*5;
+
+int response_timeout = FAN_ALLOW;
+static int min_response_timeout = FAN_ALLOW;
+static int max_response_timeout = FAN_DENY;
+
+extern unsigned long  max_time_do_perm;
+
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+
+struct ctl_table fanotify_table[] = {
+	{
+		.procname	= "max_time_do_perm",
+		.data		= &max_time_do_perm,
+		.maxlen		= sizeof(max_time_do_perm),
+		.mode		= 0444,
+		.proc_handler	= proc_doulongvec_minmax,
+	},
+	{
+		.procname	= "time_wait_response",
+		.data		= &time_wait_response,
+		.maxlen		= sizeof(time_wait_response),
+		.mode		= 0644,
+		.proc_handler	= proc_doulongvec_ms_jiffies_minmax,
+		.extra1         = &min_time_wait_response,
+		.extra2         = &max_time_wait_response,
+	},
+	{
+		.procname	= "response_timeout",
+		.data		= &response_timeout,
+		.maxlen		= sizeof(response_timeout),
+		.mode		= 0644,
+		.proc_handler	= proc_douintvec_minmax,
+		.extra1         = &min_response_timeout,
+		.extra2         = &max_response_timeout,
+	},
+	{ }
+};
+#endif /* CONFIG_SYSCTL */
+#endif /* CONFIG_FANOTIFY_ACCESS_PERMISSIONS */
+
 /*
  * Get an fsnotify notification event if one exists and is small
  * enough to fit in "count". Return an error pointer if the count
@@ -320,6 +365,7 @@ static ssize_t fanotify_read(struct file
 				wake_up(&group->fanotify_data.access_waitq);
 			} else {
 				spin_lock(&group->notification_lock);
+				FANOTIFY_PE(kevent)->stat = FANOTIFY_EVENT_SENDED;
 				list_add_tail(&kevent->list,
 					&group->fanotify_data.access_list);
 				spin_unlock(&group->notification_lock);
diff -Nurp linux-3.10.0-1127.13.1.el7.x86_64.orig/fs/notify/fsnotify.c linux-3.10.0-1127.13.1.el7.x86_64/fs/notify/fsnotify.c
--- linux-3.10.0-1127.13.1.el7.x86_64.orig/fs/notify/fsnotify.c	2020-12-04 19:34:12.231398192 +0800
+++ linux-3.10.0-1127.13.1.el7.x86_64/fs/notify/fsnotify.c	2020-12-04 19:34:39.880321208 +0800
@@ -393,7 +393,7 @@ static __init int fsnotify_init(void)
 {
 	int ret;
 
-	BUG_ON(hweight32(ALL_FSNOTIFY_EVENTS) != 23);
+	BUG_ON(hweight32(ALL_FSNOTIFY_EVENTS) != 25);
 
 	ret = init_srcu_struct(&fsnotify_mark_srcu);
 	if (ret)
diff -Nurp linux-3.10.0-1127.13.1.el7.x86_64.orig/include/linux/fanotify.h linux-3.10.0-1127.13.1.el7.x86_64/include/linux/fanotify.h
--- linux-3.10.0-1127.13.1.el7.x86_64.orig/include/linux/fanotify.h	2020-12-04 19:34:11.686419420 +0800
+++ linux-3.10.0-1127.13.1.el7.x86_64/include/linux/fanotify.h	2020-12-04 19:41:07.376320010 +0800
@@ -2,7 +2,12 @@
 #define _LINUX_FANOTIFY_H
 
 #include <uapi/linux/fanotify.h>
+#include <linux/sysctl.h>
 
 /* not valid from userspace, only kernel internal */
 #define FAN_MARK_ONDIR		0x00000100
+
+#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
+extern struct ctl_table fanotify_table[]; /* for sysctl */
+#endif
 #endif /* _LINUX_FANOTIFY_H */
diff -Nurp linux-3.10.0-1127.13.1.el7.x86_64.orig/include/linux/fsnotify_backend.h linux-3.10.0-1127.13.1.el7.x86_64/include/linux/fsnotify_backend.h
--- linux-3.10.0-1127.13.1.el7.x86_64.orig/include/linux/fsnotify_backend.h	2020-12-04 19:34:11.670420043 +0800
+++ linux-3.10.0-1127.13.1.el7.x86_64/include/linux/fsnotify_backend.h	2020-12-04 19:41:37.148852263 +0800
@@ -35,6 +35,7 @@
 #define FS_DELETE		0x00000200	/* Subfile was deleted */
 #define FS_DELETE_SELF		0x00000400	/* Self was deleted */
 #define FS_MOVE_SELF		0x00000800	/* Self was moved */
+#define FS_OPEN_EXEC		0x00001000      /* File was opened for exec */
 
 #define FS_UNMOUNT		0x00002000	/* inode on umount fs */
 #define FS_Q_OVERFLOW		0x00004000	/* Event queued overflowed */
@@ -42,6 +43,7 @@
 
 #define FS_OPEN_PERM		0x00010000	/* open event in an permission hook */
 #define FS_ACCESS_PERM		0x00020000	/* access event in a permissions hook */
+#define FS_OPEN_EXEC_PERM	0x00040000	/* open/exec event in a permission hook */
 
 #define FS_EXCL_UNLINK		0x04000000	/* do not send events if object is unlinked */
 #define FS_ISDIR		0x40000000	/* event occurred against dir */
@@ -59,11 +61,12 @@
 #define FS_EVENTS_POSS_ON_CHILD   (FS_ACCESS | FS_MODIFY | FS_ATTRIB |\
 				   FS_CLOSE_WRITE | FS_CLOSE_NOWRITE | FS_OPEN |\
 				   FS_MOVED_FROM | FS_MOVED_TO | FS_CREATE |\
-				   FS_DELETE | FS_OPEN_PERM | FS_ACCESS_PERM)
+				   FS_DELETE | FS_OPEN_PERM | FS_ACCESS_PERM |\
+				   FS_OPEN_EXEC | FS_OPEN_EXEC_PERM)
 
 #define FS_MOVE			(FS_MOVED_FROM | FS_MOVED_TO)
 
-#define ALL_FSNOTIFY_PERM_EVENTS (FS_OPEN_PERM | FS_ACCESS_PERM)
+#define ALL_FSNOTIFY_PERM_EVENTS (FS_OPEN_PERM | FS_ACCESS_PERM | FS_OPEN_EXEC_PERM)
 
 #define ALL_FSNOTIFY_EVENTS (FS_ACCESS | FS_MODIFY | FS_ATTRIB | \
 			     FS_CLOSE_WRITE | FS_CLOSE_NOWRITE | FS_OPEN | \
@@ -72,7 +75,8 @@
 			     FS_UNMOUNT | FS_Q_OVERFLOW | FS_IN_IGNORED | \
 			     FS_OPEN_PERM | FS_ACCESS_PERM | FS_EXCL_UNLINK | \
 			     FS_ISDIR | FS_IN_ONESHOT | FS_DN_RENAME | \
-			     FS_DN_MULTISHOT | FS_EVENT_ON_CHILD)
+			     FS_DN_MULTISHOT | FS_EVENT_ON_CHILD |\
+			     FS_OPEN_EXEC | FS_OPEN_EXEC_PERM)
 
 struct fsnotify_group;
 struct fsnotify_event;
diff -Nurp linux-3.10.0-1127.13.1.el7.x86_64.orig/include/linux/fsnotify.h linux-3.10.0-1127.13.1.el7.x86_64/include/linux/fsnotify.h
--- linux-3.10.0-1127.13.1.el7.x86_64.orig/include/linux/fsnotify.h	2020-12-04 19:34:11.683419537 +0800
+++ linux-3.10.0-1127.13.1.el7.x86_64/include/linux/fsnotify.h	2020-12-04 19:34:39.881321169 +0800
@@ -25,6 +25,20 @@ static inline int fsnotify_parent(const
 	return __fsnotify_parent(path, dentry, mask);
 }
 
+/*
+ * Simple wrapper to consolidate calls fsnotify_parent()/fsnotify() when
+ * an event is on a path.
+ */
+static inline int fsnotify_path(struct inode *inode, const struct path *path,
+                                __u32 mask)
+{
+        int ret = fsnotify_parent(path, NULL, mask);
+
+        if (ret)
+                return ret;
+        return fsnotify(inode, mask, path, FSNOTIFY_EVENT_PATH, NULL, 0);
+}
+
 /* simple call site for access decisions */
 static inline int fsnotify_perm(struct file *file, int mask)
 {
@@ -41,12 +55,16 @@ static inline int fsnotify_perm(struct f
 		return 0;
 	if (!(mask & (MAY_READ | MAY_OPEN)))
 		return 0;
-	if (mask & MAY_OPEN)
+	if (mask & MAY_OPEN) {
 		fsnotify_mask = FS_OPEN_PERM;
-	else if (mask & MAY_READ)
+		if (file->f_flags & __FMODE_EXEC) {
+			ret = fsnotify_path(inode, path, FS_OPEN_EXEC_PERM);
+			if (ret)
+				return ret;
+		}
+	} else if (mask & MAY_READ) {
 		fsnotify_mask = FS_ACCESS_PERM;
-	else
-		BUG();
+	}
 
 	ret = fsnotify_parent(path, NULL, fsnotify_mask);
 	if (ret)
@@ -218,6 +236,8 @@ static inline void fsnotify_open(struct
 
 	if (S_ISDIR(inode->i_mode))
 		mask |= FS_ISDIR;
+	if (file->f_flags & __FMODE_EXEC)
+		mask |= FS_OPEN_EXEC;
 
 	fsnotify_parent(path, NULL, mask);
 	fsnotify(inode, mask, path, FSNOTIFY_EVENT_PATH, NULL, 0);
diff -Nurp linux-3.10.0-1127.13.1.el7.x86_64.orig/include/uapi/linux/fanotify.h linux-3.10.0-1127.13.1.el7.x86_64/include/uapi/linux/fanotify.h
--- linux-3.10.0-1127.13.1.el7.x86_64.orig/include/uapi/linux/fanotify.h	2020-12-04 19:34:11.633421484 +0800
+++ linux-3.10.0-1127.13.1.el7.x86_64/include/uapi/linux/fanotify.h	2020-12-04 19:34:39.881321169 +0800
@@ -9,11 +9,13 @@
 #define FAN_CLOSE_WRITE		0x00000008	/* Writtable file closed */
 #define FAN_CLOSE_NOWRITE	0x00000010	/* Unwrittable file closed */
 #define FAN_OPEN		0x00000020	/* File was opened */
+#define FAN_OPEN_EXEC		0x00001000      /* File was opened for exec */
 
 #define FAN_Q_OVERFLOW		0x00004000	/* Event queued overflowed */
 
 #define FAN_OPEN_PERM		0x00010000	/* File open in perm check */
 #define FAN_ACCESS_PERM		0x00020000	/* File accessed in perm check */
+#define FAN_OPEN_EXEC_PERM	0x00040000	/* File open/exec in perm check */
 
 #define FAN_ONDIR		0x40000000	/* event occurred against dir */
 
@@ -68,13 +70,15 @@
 #define FAN_ALL_EVENTS (FAN_ACCESS |\
 			FAN_MODIFY |\
 			FAN_CLOSE |\
-			FAN_OPEN)
+			FAN_OPEN |\
+			FAN_OPEN_EXEC)
 
 /*
  * All events which require a permission response from userspace
  */
 #define FAN_ALL_PERM_EVENTS (FAN_OPEN_PERM |\
-			     FAN_ACCESS_PERM)
+			     FAN_ACCESS_PERM |\
+			     FAN_OPEN_EXEC_PERM)
 
 #define FAN_ALL_OUTGOING_EVENTS	(FAN_ALL_EVENTS |\
 				 FAN_ALL_PERM_EVENTS |\
diff -Nurp linux-3.10.0-1127.13.1.el7.x86_64.orig/kernel/sysctl.c linux-3.10.0-1127.13.1.el7.x86_64/kernel/sysctl.c
--- linux-3.10.0-1127.13.1.el7.x86_64.orig/kernel/sysctl.c	2020-12-04 19:34:12.213398893 +0800
+++ linux-3.10.0-1127.13.1.el7.x86_64/kernel/sysctl.c	2020-12-04 19:34:39.881321169 +0800
@@ -156,6 +156,9 @@ static unsigned long hung_task_timeout_m
 #ifdef CONFIG_INOTIFY_USER
 #include <linux/inotify.h>
 #endif
+#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS 
+#include <linux/fanotify.h>
+#endif
 #ifdef CONFIG_SPARC
 #endif
 
@@ -1731,6 +1734,13 @@ static struct ctl_table fs_table[] = {
 		.child		= inotify_table,
 	},
 #endif	
+#ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS 
+	{
+		.procname	= "fanotify",
+		.mode		= 0555,
+		.child		= fanotify_table,
+	},
+#endif	
 #ifdef CONFIG_EPOLL
 	{
 		.procname	= "epoll",
